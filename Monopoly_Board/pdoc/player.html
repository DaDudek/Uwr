<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>player API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>player</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Player:
    def __init__(self, board):
        &#34;&#34;&#34;
        Constructor of player class

        :param board: (board)

        number (int) player number - between 1 and 4
        in_bankrupt (boolean) flag to know if player bankrupt
        money - (int/double) give information about how much money player have
        coordinate - (int) coordinate where player is  - between 0 and 39
        number_of_houses (int) flag to check how many house player have (for future)
        number_of_hotel (int) flag to check how many hotel player have (for future)
        property - (list) list of cell that player have (card objects not int)
        countries - (dict) key is country kind (yellow, red etc),
                            value is list of card objects form that country that player have
        in_prison - (int) flag to know if the player is in prison
        prison_counter - (int) flag to know how many turn more player is in prison
        out_of_prison - (int) flag to know that player have &#34;out of jail card&#34; - for future
        have_pair - (boolean) flag to know that player can roll dice again
        &#34;&#34;&#34;
        self.number = 0
        self.is_bankrupt = False
        self.money = 15000000
        self.coordinate = 0
        self.number_of_houses = 0
        self.number_of_hotel = 0
        self.property = []
        self.countries = {}  # key section value number of cell
        self.in_prison = False
        self.prison_counter = 0
        self.out_of_prison = 0
        self.pair_counter = 0
        self.have_pair = False
        board.players_queue.append(self)
        board.board[0].append(self)

    def card_out_of_prison(self):
        &#34;&#34;&#34;
        The function to return how many out_of_jail cards player have (for future)

        :return: (int) value of how many cards
        &#34;&#34;&#34;
        return self.out_of_prison

    def out_of_prison_by_cash(self):
        &#34;&#34;&#34;
        This function is used to go out from jail using cash (one of three option)

        :return: void -&gt; (only change objects)
        &#34;&#34;&#34;
        self.in_prison = False
        self.prison_counter = 0
        self.money -= 500 * 1000

    def out_of_prison_by_card(self):
        &#34;&#34;&#34;
            This function is used to go out from jail using card (one of three option, for future)

            :return: void -&gt; (only change objects)
        &#34;&#34;&#34;
        if self.out_of_prison &gt; 0:
            self.in_prison = False
            self.prison_counter = 0
            self.out_of_prison -= 1

    def stand_in_prison(self):
        &#34;&#34;&#34;
            This function is used to count turn if player in prison  (if player in prison he lose 2 turn)

            :return: void -&gt; (only change objects)
        &#34;&#34;&#34;
        if self.prison_counter &gt; 0:
            self.prison_counter -= 1
        else:
            self.in_prison = 0

    def go_bankrupt(self):
        &#34;&#34;&#34;
        This function is used to free all the cells when player is bankrupt

        :return: void -&gt; (only change objects)
        &#34;&#34;&#34;
        self.number_of_houses = 0
        self.number_of_hotel = 0
        for card in self.property:
            card.owner = None
        self.property = []
        self.countries = {}
        self.in_prison = False
        self.prison_counter = 0
        self.out_of_prison = 0
        self.pair_counter = 0
        self.have_pair = False
        self.is_bankrupt = True

    def make_trade(self, seller, card, buyer, cost):
        &#34;&#34;&#34;
        This function is used to make trade between two player - one of them pays
                                                                    to get a cell that the second one have

        :param seller: (player) person who is selling
        :param card: (card) cell that is gonna be sell
        :param buyer: (player) player who bought cell
        :param cost: (int) how much seller get for selling the cell

        :return: void -&gt; only change objects
        &#34;&#34;&#34;
        seller.money += cost
        buyer.money -= cost
        seller.property.remove(card)
        buyer.property.append(card)
        seller.countries[card.section].remove(card.coordinate)
        if card.section in buyer.countries:
            buyer.countries[card.section].append(card.coordinate)
        else:
            buyer.countries[card.section] = [card.coordinate]
        card.owner = buyer

    def sell_to_player(self, player, card, cost):
        &#34;&#34;&#34;
        This function first check if player can sell a cell to another player and after using make trade to do this
         # who sell, who buy, what buy, what is a prize

        :param player: (player) player who is gonna to buy a cell
        :param card: (card) what sell is going to be sold
        :param cost: (int) what is a prize for cell

        :return:  void -&gt; only change objects
        &#34;&#34;&#34;
        if (card.coordinate in [5, 15, 25, 35] or not (card.number_of_houses or card.number_of_hotel))\
                and player.money &gt;= cost:
            self.make_trade(self, card, player, cost)

    def check_for_buying_house(self, board, cell):
        &#34;&#34;&#34;
        This function is used to check is player is able to buy a house on some cell

        :param board: (board) background logic of board
        :param cell: (cell) where player want to stand house

        :return: (boolean) True if player is able, False if not
        &#34;&#34;&#34;
        if cell.section in self.countries and self.money &gt; cell.house_prize and\
                cell.number_of_houses &lt; 4 and not cell.number_of_hotel:
            for place in board.sector[cell.section]:
                if place not in self.countries[cell.section]:
                    return False
            return True
        return False

    def check_for_buying_hotel(self, cell):
        &#34;&#34;&#34;
            This function is used to check is player is able to buy a house on some cell
                we don&#39;t need board object because if houses stand on cell than we are sure he have country

            :param cell: (cell) where player want to stand house

            :return: (boolean) True if player is able, False if not
        &#34;&#34;&#34;
        if cell.number_of_houses == 4 and self.money &gt; cell.hotel_prize and cell.number_of_hotel &lt; 1:
            return True
        return False

    def check_for_sell(self, cell, background):
        &#34;&#34;&#34;
        This function is used to check is player is able to sell cell (to other player or to bank)
            we check power_station alone because this kind of cells don&#39;t have house/hotel
            we also check the traspont because we use fake houses there

        :param cell: (cell) cell that player want to sell
        :param background: (board) background logic of board

        :return: (int) return 0 if player is not able or 1 if he is
        &#34;&#34;&#34;
        if cell.owner != self:
            return 0
        if cell.section == &#34;power_station&#34; or cell.section == &#34;transport&#34;:
            return 1
        for city in self.countries[cell.section]:
            if background.board[city][0].number_of_hotel or background.board[city][0].number_of_houses:
                return 0
        return 1

    def buy_house(self, board, cell):
        &#34;&#34;&#34;
        This function first check is player is able to buy cell and if he is, function do it

        :param board: (board) background logic of board
        :param cell: (cell) cell that player want to buy

        :return: void -&gt; only change object
        &#34;&#34;&#34;
        if self.check_for_buying_house(board, cell):
            self.number_of_houses += 1
            self.money -= cell.house_prize
            cell.number_of_houses += 1

    def buy_hotel(self, cell):
        &#34;&#34;&#34;
        This function first check is player is able to buy hotel and if he is, function do it

        :param cell: (cell) cell where player want to stand hotel

        :return: void -&gt; only change object
        &#34;&#34;&#34;
        if self.check_for_buying_hotel(cell):
            self.number_of_hotel += 1
            self.money -= cell.hotel_prize
            cell.number_of_hotel += 1
            cell.number_of_houses = 0

    def sell_house(self, cell):
        &#34;&#34;&#34;
        This function first check is player have houses on cell, and if he is function sell it

        :param cell: (cell) cell where player want to stand hotel

        :return: void -&gt; only change object
        &#34;&#34;&#34;
        if cell.number_of_houses &gt; 0:
            cell.number_of_houses -= 1
            self.money += int(cell.house_prize * 0.5)
            self.number_of_houses -= 1

    def sell_hotel(self, cell):
        &#34;&#34;&#34;
            This function first check is player have hotel on cell, and if he is function sell it

            :param cell: (cell) cell where player want to stand hotel

            :return: void -&gt; only change object
            &#34;&#34;&#34;
        if cell.number_of_hotel &gt; 0:
            cell.number_of_hotel -= 1
            self.money += cell.hotel_prize * 0.5
            self.number_of_hotel -= 1

    def move(self, board, x, y):
        &#34;&#34;&#34;
        This function is used to move player,
            first check is prison_counter  is 0 to give information about not being in prison/end of being there
            than function check is player have pair (if yes and its not third time in row he have another move)
            if it is third time in row player go to prison, if player don&#39;t have pair he is moved on the end of queue
            and deleting from cell where he was before throw the dice.
            In the end function check is player went through the start and if its true he get money

        :param board: (board) background logic of board
        :param x: (int) what is score of first dice (between 1 and 6)
        :param y: (int) what is score of second dice (between 1 and 6)

        :return: 1 if player must go to jail/is in jail, 0 in other case
        &#34;&#34;&#34;
        if self.prison_counter == 0:
            self.in_prison = False
            how_many_cells = y + x
            if x == y:
                self.have_pair = True
                self.pair_counter += 1
                if self.pair_counter == 3:
                    self.pair_counter = 0
                    self.have_pair = False
                    self.in_prison = 1
                    self.prison_counter = 2
                    self.coordinate = 10
                    board.board[10].append(self)
                    return 1
            else:
                self.pair_counter = 0
                self.have_pair = False
                queue = board.players_queue[1:]
                board.players_queue = queue
                board.players_queue.append(self)
            del board.board[self.coordinate][1]  # board.board[x][0] is always card
            if self.coordinate + how_many_cells &gt; 39:
                self.money += 2000 * 1000
            board.board[(self.coordinate + how_many_cells) % 40].append(self)
            self.coordinate = (self.coordinate + how_many_cells) % 40
            return 0
        else:
            return 1

    def bank_account(self):
        &#34;&#34;&#34;
        This function is used to return how much player have money

        :return: (double) return how much player have money
        &#34;&#34;&#34;
        return self.money

    def paid_tax(self, amout_of_tax):
        &#34;&#34;&#34;
        This function is used to &#34;paid tax&#34; when player stand on tax cell

        :param amout_of_tax: (int) how much player must paid ( he paid to bank - just lose money)

        :return: void -&gt; only change objects
        &#34;&#34;&#34;
        self.money -= amout_of_tax

    def __str__(self):
        return str(self.number) + &#34; pieniądze: &#34; + str(self.money) + &#34; posiadłości: &#34; + &#34; ,&#34;.join(
            [x.name for x in self.property])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="player.Player"><code class="flex name class">
<span>class <span class="ident">Player</span></span>
<span>(</span><span>board)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructor of player class</p>
<p>:param board: (board)</p>
<p>number (int) player number - between 1 and 4
in_bankrupt (boolean) flag to know if player bankrupt
money - (int/double) give information about how much money player have
coordinate - (int) coordinate where player is
- between 0 and 39
number_of_houses (int) flag to check how many house player have (for future)
number_of_hotel (int) flag to check how many hotel player have (for future)
property - (list) list of cell that player have (card objects not int)
countries - (dict) key is country kind (yellow, red etc),
value is list of card objects form that country that player have
in_prison - (int) flag to know if the player is in prison
prison_counter - (int) flag to know how many turn more player is in prison
out_of_prison - (int) flag to know that player have "out of jail card" - for future
have_pair - (boolean) flag to know that player can roll dice again</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Player:
    def __init__(self, board):
        &#34;&#34;&#34;
        Constructor of player class

        :param board: (board)

        number (int) player number - between 1 and 4
        in_bankrupt (boolean) flag to know if player bankrupt
        money - (int/double) give information about how much money player have
        coordinate - (int) coordinate where player is  - between 0 and 39
        number_of_houses (int) flag to check how many house player have (for future)
        number_of_hotel (int) flag to check how many hotel player have (for future)
        property - (list) list of cell that player have (card objects not int)
        countries - (dict) key is country kind (yellow, red etc),
                            value is list of card objects form that country that player have
        in_prison - (int) flag to know if the player is in prison
        prison_counter - (int) flag to know how many turn more player is in prison
        out_of_prison - (int) flag to know that player have &#34;out of jail card&#34; - for future
        have_pair - (boolean) flag to know that player can roll dice again
        &#34;&#34;&#34;
        self.number = 0
        self.is_bankrupt = False
        self.money = 15000000
        self.coordinate = 0
        self.number_of_houses = 0
        self.number_of_hotel = 0
        self.property = []
        self.countries = {}  # key section value number of cell
        self.in_prison = False
        self.prison_counter = 0
        self.out_of_prison = 0
        self.pair_counter = 0
        self.have_pair = False
        board.players_queue.append(self)
        board.board[0].append(self)

    def card_out_of_prison(self):
        &#34;&#34;&#34;
        The function to return how many out_of_jail cards player have (for future)

        :return: (int) value of how many cards
        &#34;&#34;&#34;
        return self.out_of_prison

    def out_of_prison_by_cash(self):
        &#34;&#34;&#34;
        This function is used to go out from jail using cash (one of three option)

        :return: void -&gt; (only change objects)
        &#34;&#34;&#34;
        self.in_prison = False
        self.prison_counter = 0
        self.money -= 500 * 1000

    def out_of_prison_by_card(self):
        &#34;&#34;&#34;
            This function is used to go out from jail using card (one of three option, for future)

            :return: void -&gt; (only change objects)
        &#34;&#34;&#34;
        if self.out_of_prison &gt; 0:
            self.in_prison = False
            self.prison_counter = 0
            self.out_of_prison -= 1

    def stand_in_prison(self):
        &#34;&#34;&#34;
            This function is used to count turn if player in prison  (if player in prison he lose 2 turn)

            :return: void -&gt; (only change objects)
        &#34;&#34;&#34;
        if self.prison_counter &gt; 0:
            self.prison_counter -= 1
        else:
            self.in_prison = 0

    def go_bankrupt(self):
        &#34;&#34;&#34;
        This function is used to free all the cells when player is bankrupt

        :return: void -&gt; (only change objects)
        &#34;&#34;&#34;
        self.number_of_houses = 0
        self.number_of_hotel = 0
        for card in self.property:
            card.owner = None
        self.property = []
        self.countries = {}
        self.in_prison = False
        self.prison_counter = 0
        self.out_of_prison = 0
        self.pair_counter = 0
        self.have_pair = False
        self.is_bankrupt = True

    def make_trade(self, seller, card, buyer, cost):
        &#34;&#34;&#34;
        This function is used to make trade between two player - one of them pays
                                                                    to get a cell that the second one have

        :param seller: (player) person who is selling
        :param card: (card) cell that is gonna be sell
        :param buyer: (player) player who bought cell
        :param cost: (int) how much seller get for selling the cell

        :return: void -&gt; only change objects
        &#34;&#34;&#34;
        seller.money += cost
        buyer.money -= cost
        seller.property.remove(card)
        buyer.property.append(card)
        seller.countries[card.section].remove(card.coordinate)
        if card.section in buyer.countries:
            buyer.countries[card.section].append(card.coordinate)
        else:
            buyer.countries[card.section] = [card.coordinate]
        card.owner = buyer

    def sell_to_player(self, player, card, cost):
        &#34;&#34;&#34;
        This function first check if player can sell a cell to another player and after using make trade to do this
         # who sell, who buy, what buy, what is a prize

        :param player: (player) player who is gonna to buy a cell
        :param card: (card) what sell is going to be sold
        :param cost: (int) what is a prize for cell

        :return:  void -&gt; only change objects
        &#34;&#34;&#34;
        if (card.coordinate in [5, 15, 25, 35] or not (card.number_of_houses or card.number_of_hotel))\
                and player.money &gt;= cost:
            self.make_trade(self, card, player, cost)

    def check_for_buying_house(self, board, cell):
        &#34;&#34;&#34;
        This function is used to check is player is able to buy a house on some cell

        :param board: (board) background logic of board
        :param cell: (cell) where player want to stand house

        :return: (boolean) True if player is able, False if not
        &#34;&#34;&#34;
        if cell.section in self.countries and self.money &gt; cell.house_prize and\
                cell.number_of_houses &lt; 4 and not cell.number_of_hotel:
            for place in board.sector[cell.section]:
                if place not in self.countries[cell.section]:
                    return False
            return True
        return False

    def check_for_buying_hotel(self, cell):
        &#34;&#34;&#34;
            This function is used to check is player is able to buy a house on some cell
                we don&#39;t need board object because if houses stand on cell than we are sure he have country

            :param cell: (cell) where player want to stand house

            :return: (boolean) True if player is able, False if not
        &#34;&#34;&#34;
        if cell.number_of_houses == 4 and self.money &gt; cell.hotel_prize and cell.number_of_hotel &lt; 1:
            return True
        return False

    def check_for_sell(self, cell, background):
        &#34;&#34;&#34;
        This function is used to check is player is able to sell cell (to other player or to bank)
            we check power_station alone because this kind of cells don&#39;t have house/hotel
            we also check the traspont because we use fake houses there

        :param cell: (cell) cell that player want to sell
        :param background: (board) background logic of board

        :return: (int) return 0 if player is not able or 1 if he is
        &#34;&#34;&#34;
        if cell.owner != self:
            return 0
        if cell.section == &#34;power_station&#34; or cell.section == &#34;transport&#34;:
            return 1
        for city in self.countries[cell.section]:
            if background.board[city][0].number_of_hotel or background.board[city][0].number_of_houses:
                return 0
        return 1

    def buy_house(self, board, cell):
        &#34;&#34;&#34;
        This function first check is player is able to buy cell and if he is, function do it

        :param board: (board) background logic of board
        :param cell: (cell) cell that player want to buy

        :return: void -&gt; only change object
        &#34;&#34;&#34;
        if self.check_for_buying_house(board, cell):
            self.number_of_houses += 1
            self.money -= cell.house_prize
            cell.number_of_houses += 1

    def buy_hotel(self, cell):
        &#34;&#34;&#34;
        This function first check is player is able to buy hotel and if he is, function do it

        :param cell: (cell) cell where player want to stand hotel

        :return: void -&gt; only change object
        &#34;&#34;&#34;
        if self.check_for_buying_hotel(cell):
            self.number_of_hotel += 1
            self.money -= cell.hotel_prize
            cell.number_of_hotel += 1
            cell.number_of_houses = 0

    def sell_house(self, cell):
        &#34;&#34;&#34;
        This function first check is player have houses on cell, and if he is function sell it

        :param cell: (cell) cell where player want to stand hotel

        :return: void -&gt; only change object
        &#34;&#34;&#34;
        if cell.number_of_houses &gt; 0:
            cell.number_of_houses -= 1
            self.money += int(cell.house_prize * 0.5)
            self.number_of_houses -= 1

    def sell_hotel(self, cell):
        &#34;&#34;&#34;
            This function first check is player have hotel on cell, and if he is function sell it

            :param cell: (cell) cell where player want to stand hotel

            :return: void -&gt; only change object
            &#34;&#34;&#34;
        if cell.number_of_hotel &gt; 0:
            cell.number_of_hotel -= 1
            self.money += cell.hotel_prize * 0.5
            self.number_of_hotel -= 1

    def move(self, board, x, y):
        &#34;&#34;&#34;
        This function is used to move player,
            first check is prison_counter  is 0 to give information about not being in prison/end of being there
            than function check is player have pair (if yes and its not third time in row he have another move)
            if it is third time in row player go to prison, if player don&#39;t have pair he is moved on the end of queue
            and deleting from cell where he was before throw the dice.
            In the end function check is player went through the start and if its true he get money

        :param board: (board) background logic of board
        :param x: (int) what is score of first dice (between 1 and 6)
        :param y: (int) what is score of second dice (between 1 and 6)

        :return: 1 if player must go to jail/is in jail, 0 in other case
        &#34;&#34;&#34;
        if self.prison_counter == 0:
            self.in_prison = False
            how_many_cells = y + x
            if x == y:
                self.have_pair = True
                self.pair_counter += 1
                if self.pair_counter == 3:
                    self.pair_counter = 0
                    self.have_pair = False
                    self.in_prison = 1
                    self.prison_counter = 2
                    self.coordinate = 10
                    board.board[10].append(self)
                    return 1
            else:
                self.pair_counter = 0
                self.have_pair = False
                queue = board.players_queue[1:]
                board.players_queue = queue
                board.players_queue.append(self)
            del board.board[self.coordinate][1]  # board.board[x][0] is always card
            if self.coordinate + how_many_cells &gt; 39:
                self.money += 2000 * 1000
            board.board[(self.coordinate + how_many_cells) % 40].append(self)
            self.coordinate = (self.coordinate + how_many_cells) % 40
            return 0
        else:
            return 1

    def bank_account(self):
        &#34;&#34;&#34;
        This function is used to return how much player have money

        :return: (double) return how much player have money
        &#34;&#34;&#34;
        return self.money

    def paid_tax(self, amout_of_tax):
        &#34;&#34;&#34;
        This function is used to &#34;paid tax&#34; when player stand on tax cell

        :param amout_of_tax: (int) how much player must paid ( he paid to bank - just lose money)

        :return: void -&gt; only change objects
        &#34;&#34;&#34;
        self.money -= amout_of_tax

    def __str__(self):
        return str(self.number) + &#34; pieniądze: &#34; + str(self.money) + &#34; posiadłości: &#34; + &#34; ,&#34;.join(
            [x.name for x in self.property])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="player.Player.bank_account"><code class="name flex">
<span>def <span class="ident">bank_account</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to return how much player have money</p>
<p>:return: (double) return how much player have money</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bank_account(self):
    &#34;&#34;&#34;
    This function is used to return how much player have money

    :return: (double) return how much player have money
    &#34;&#34;&#34;
    return self.money</code></pre>
</details>
</dd>
<dt id="player.Player.buy_hotel"><code class="name flex">
<span>def <span class="ident">buy_hotel</span></span>(<span>self, cell)</span>
</code></dt>
<dd>
<div class="desc"><p>This function first check is player is able to buy hotel and if he is, function do it</p>
<p>:param cell: (cell) cell where player want to stand hotel</p>
<p>:return: void -&gt; only change object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buy_hotel(self, cell):
    &#34;&#34;&#34;
    This function first check is player is able to buy hotel and if he is, function do it

    :param cell: (cell) cell where player want to stand hotel

    :return: void -&gt; only change object
    &#34;&#34;&#34;
    if self.check_for_buying_hotel(cell):
        self.number_of_hotel += 1
        self.money -= cell.hotel_prize
        cell.number_of_hotel += 1
        cell.number_of_houses = 0</code></pre>
</details>
</dd>
<dt id="player.Player.buy_house"><code class="name flex">
<span>def <span class="ident">buy_house</span></span>(<span>self, board, cell)</span>
</code></dt>
<dd>
<div class="desc"><p>This function first check is player is able to buy cell and if he is, function do it</p>
<p>:param board: (board) background logic of board
:param cell: (cell) cell that player want to buy</p>
<p>:return: void -&gt; only change object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buy_house(self, board, cell):
    &#34;&#34;&#34;
    This function first check is player is able to buy cell and if he is, function do it

    :param board: (board) background logic of board
    :param cell: (cell) cell that player want to buy

    :return: void -&gt; only change object
    &#34;&#34;&#34;
    if self.check_for_buying_house(board, cell):
        self.number_of_houses += 1
        self.money -= cell.house_prize
        cell.number_of_houses += 1</code></pre>
</details>
</dd>
<dt id="player.Player.card_out_of_prison"><code class="name flex">
<span>def <span class="ident">card_out_of_prison</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The function to return how many out_of_jail cards player have (for future)</p>
<p>:return: (int) value of how many cards</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def card_out_of_prison(self):
    &#34;&#34;&#34;
    The function to return how many out_of_jail cards player have (for future)

    :return: (int) value of how many cards
    &#34;&#34;&#34;
    return self.out_of_prison</code></pre>
</details>
</dd>
<dt id="player.Player.check_for_buying_hotel"><code class="name flex">
<span>def <span class="ident">check_for_buying_hotel</span></span>(<span>self, cell)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to check is player is able to buy a house on some cell
we don't need board object because if houses stand on cell than we are sure he have country</p>
<p>:param cell: (cell) where player want to stand house</p>
<p>:return: (boolean) True if player is able, False if not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_buying_hotel(self, cell):
    &#34;&#34;&#34;
        This function is used to check is player is able to buy a house on some cell
            we don&#39;t need board object because if houses stand on cell than we are sure he have country

        :param cell: (cell) where player want to stand house

        :return: (boolean) True if player is able, False if not
    &#34;&#34;&#34;
    if cell.number_of_houses == 4 and self.money &gt; cell.hotel_prize and cell.number_of_hotel &lt; 1:
        return True
    return False</code></pre>
</details>
</dd>
<dt id="player.Player.check_for_buying_house"><code class="name flex">
<span>def <span class="ident">check_for_buying_house</span></span>(<span>self, board, cell)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to check is player is able to buy a house on some cell</p>
<p>:param board: (board) background logic of board
:param cell: (cell) where player want to stand house</p>
<p>:return: (boolean) True if player is able, False if not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_buying_house(self, board, cell):
    &#34;&#34;&#34;
    This function is used to check is player is able to buy a house on some cell

    :param board: (board) background logic of board
    :param cell: (cell) where player want to stand house

    :return: (boolean) True if player is able, False if not
    &#34;&#34;&#34;
    if cell.section in self.countries and self.money &gt; cell.house_prize and\
            cell.number_of_houses &lt; 4 and not cell.number_of_hotel:
        for place in board.sector[cell.section]:
            if place not in self.countries[cell.section]:
                return False
        return True
    return False</code></pre>
</details>
</dd>
<dt id="player.Player.check_for_sell"><code class="name flex">
<span>def <span class="ident">check_for_sell</span></span>(<span>self, cell, background)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to check is player is able to sell cell (to other player or to bank)
we check power_station alone because this kind of cells don't have house/hotel
we also check the traspont because we use fake houses there</p>
<p>:param cell: (cell) cell that player want to sell
:param background: (board) background logic of board</p>
<p>:return: (int) return 0 if player is not able or 1 if he is</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_sell(self, cell, background):
    &#34;&#34;&#34;
    This function is used to check is player is able to sell cell (to other player or to bank)
        we check power_station alone because this kind of cells don&#39;t have house/hotel
        we also check the traspont because we use fake houses there

    :param cell: (cell) cell that player want to sell
    :param background: (board) background logic of board

    :return: (int) return 0 if player is not able or 1 if he is
    &#34;&#34;&#34;
    if cell.owner != self:
        return 0
    if cell.section == &#34;power_station&#34; or cell.section == &#34;transport&#34;:
        return 1
    for city in self.countries[cell.section]:
        if background.board[city][0].number_of_hotel or background.board[city][0].number_of_houses:
            return 0
    return 1</code></pre>
</details>
</dd>
<dt id="player.Player.go_bankrupt"><code class="name flex">
<span>def <span class="ident">go_bankrupt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to free all the cells when player is bankrupt</p>
<p>:return: void -&gt; (only change objects)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def go_bankrupt(self):
    &#34;&#34;&#34;
    This function is used to free all the cells when player is bankrupt

    :return: void -&gt; (only change objects)
    &#34;&#34;&#34;
    self.number_of_houses = 0
    self.number_of_hotel = 0
    for card in self.property:
        card.owner = None
    self.property = []
    self.countries = {}
    self.in_prison = False
    self.prison_counter = 0
    self.out_of_prison = 0
    self.pair_counter = 0
    self.have_pair = False
    self.is_bankrupt = True</code></pre>
</details>
</dd>
<dt id="player.Player.make_trade"><code class="name flex">
<span>def <span class="ident">make_trade</span></span>(<span>self, seller, card, buyer, cost)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to make trade between two player - one of them pays
to get a cell that the second one have</p>
<p>:param seller: (player) person who is selling
:param card: (card) cell that is gonna be sell
:param buyer: (player) player who bought cell
:param cost: (int) how much seller get for selling the cell</p>
<p>:return: void -&gt; only change objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_trade(self, seller, card, buyer, cost):
    &#34;&#34;&#34;
    This function is used to make trade between two player - one of them pays
                                                                to get a cell that the second one have

    :param seller: (player) person who is selling
    :param card: (card) cell that is gonna be sell
    :param buyer: (player) player who bought cell
    :param cost: (int) how much seller get for selling the cell

    :return: void -&gt; only change objects
    &#34;&#34;&#34;
    seller.money += cost
    buyer.money -= cost
    seller.property.remove(card)
    buyer.property.append(card)
    seller.countries[card.section].remove(card.coordinate)
    if card.section in buyer.countries:
        buyer.countries[card.section].append(card.coordinate)
    else:
        buyer.countries[card.section] = [card.coordinate]
    card.owner = buyer</code></pre>
</details>
</dd>
<dt id="player.Player.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, board, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to move player,
first check is prison_counter
is 0 to give information about not being in prison/end of being there
than function check is player have pair (if yes and its not third time in row he have another move)
if it is third time in row player go to prison, if player don't have pair he is moved on the end of queue
and deleting from cell where he was before throw the dice.
In the end function check is player went through the start and if its true he get money</p>
<p>:param board: (board) background logic of board
:param x: (int) what is score of first dice (between 1 and 6)
:param y: (int) what is score of second dice (between 1 and 6)</p>
<p>:return: 1 if player must go to jail/is in jail, 0 in other case</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, board, x, y):
    &#34;&#34;&#34;
    This function is used to move player,
        first check is prison_counter  is 0 to give information about not being in prison/end of being there
        than function check is player have pair (if yes and its not third time in row he have another move)
        if it is third time in row player go to prison, if player don&#39;t have pair he is moved on the end of queue
        and deleting from cell where he was before throw the dice.
        In the end function check is player went through the start and if its true he get money

    :param board: (board) background logic of board
    :param x: (int) what is score of first dice (between 1 and 6)
    :param y: (int) what is score of second dice (between 1 and 6)

    :return: 1 if player must go to jail/is in jail, 0 in other case
    &#34;&#34;&#34;
    if self.prison_counter == 0:
        self.in_prison = False
        how_many_cells = y + x
        if x == y:
            self.have_pair = True
            self.pair_counter += 1
            if self.pair_counter == 3:
                self.pair_counter = 0
                self.have_pair = False
                self.in_prison = 1
                self.prison_counter = 2
                self.coordinate = 10
                board.board[10].append(self)
                return 1
        else:
            self.pair_counter = 0
            self.have_pair = False
            queue = board.players_queue[1:]
            board.players_queue = queue
            board.players_queue.append(self)
        del board.board[self.coordinate][1]  # board.board[x][0] is always card
        if self.coordinate + how_many_cells &gt; 39:
            self.money += 2000 * 1000
        board.board[(self.coordinate + how_many_cells) % 40].append(self)
        self.coordinate = (self.coordinate + how_many_cells) % 40
        return 0
    else:
        return 1</code></pre>
</details>
</dd>
<dt id="player.Player.out_of_prison_by_card"><code class="name flex">
<span>def <span class="ident">out_of_prison_by_card</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to go out from jail using card (one of three option, for future)</p>
<p>:return: void -&gt; (only change objects)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def out_of_prison_by_card(self):
    &#34;&#34;&#34;
        This function is used to go out from jail using card (one of three option, for future)

        :return: void -&gt; (only change objects)
    &#34;&#34;&#34;
    if self.out_of_prison &gt; 0:
        self.in_prison = False
        self.prison_counter = 0
        self.out_of_prison -= 1</code></pre>
</details>
</dd>
<dt id="player.Player.out_of_prison_by_cash"><code class="name flex">
<span>def <span class="ident">out_of_prison_by_cash</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to go out from jail using cash (one of three option)</p>
<p>:return: void -&gt; (only change objects)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def out_of_prison_by_cash(self):
    &#34;&#34;&#34;
    This function is used to go out from jail using cash (one of three option)

    :return: void -&gt; (only change objects)
    &#34;&#34;&#34;
    self.in_prison = False
    self.prison_counter = 0
    self.money -= 500 * 1000</code></pre>
</details>
</dd>
<dt id="player.Player.paid_tax"><code class="name flex">
<span>def <span class="ident">paid_tax</span></span>(<span>self, amout_of_tax)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to "paid tax" when player stand on tax cell</p>
<p>:param amout_of_tax: (int) how much player must paid ( he paid to bank - just lose money)</p>
<p>:return: void -&gt; only change objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paid_tax(self, amout_of_tax):
    &#34;&#34;&#34;
    This function is used to &#34;paid tax&#34; when player stand on tax cell

    :param amout_of_tax: (int) how much player must paid ( he paid to bank - just lose money)

    :return: void -&gt; only change objects
    &#34;&#34;&#34;
    self.money -= amout_of_tax</code></pre>
</details>
</dd>
<dt id="player.Player.sell_hotel"><code class="name flex">
<span>def <span class="ident">sell_hotel</span></span>(<span>self, cell)</span>
</code></dt>
<dd>
<div class="desc"><p>This function first check is player have hotel on cell, and if he is function sell it</p>
<p>:param cell: (cell) cell where player want to stand hotel</p>
<p>:return: void -&gt; only change object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sell_hotel(self, cell):
    &#34;&#34;&#34;
        This function first check is player have hotel on cell, and if he is function sell it

        :param cell: (cell) cell where player want to stand hotel

        :return: void -&gt; only change object
        &#34;&#34;&#34;
    if cell.number_of_hotel &gt; 0:
        cell.number_of_hotel -= 1
        self.money += cell.hotel_prize * 0.5
        self.number_of_hotel -= 1</code></pre>
</details>
</dd>
<dt id="player.Player.sell_house"><code class="name flex">
<span>def <span class="ident">sell_house</span></span>(<span>self, cell)</span>
</code></dt>
<dd>
<div class="desc"><p>This function first check is player have houses on cell, and if he is function sell it</p>
<p>:param cell: (cell) cell where player want to stand hotel</p>
<p>:return: void -&gt; only change object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sell_house(self, cell):
    &#34;&#34;&#34;
    This function first check is player have houses on cell, and if he is function sell it

    :param cell: (cell) cell where player want to stand hotel

    :return: void -&gt; only change object
    &#34;&#34;&#34;
    if cell.number_of_houses &gt; 0:
        cell.number_of_houses -= 1
        self.money += int(cell.house_prize * 0.5)
        self.number_of_houses -= 1</code></pre>
</details>
</dd>
<dt id="player.Player.sell_to_player"><code class="name flex">
<span>def <span class="ident">sell_to_player</span></span>(<span>self, player, card, cost)</span>
</code></dt>
<dd>
<div class="desc"><p>This function first check if player can sell a cell to another player and after using make trade to do this
# who sell, who buy, what buy, what is a prize</p>
<p>:param player: (player) player who is gonna to buy a cell
:param card: (card) what sell is going to be sold
:param cost: (int) what is a prize for cell</p>
<p>:return:
void -&gt; only change objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sell_to_player(self, player, card, cost):
    &#34;&#34;&#34;
    This function first check if player can sell a cell to another player and after using make trade to do this
     # who sell, who buy, what buy, what is a prize

    :param player: (player) player who is gonna to buy a cell
    :param card: (card) what sell is going to be sold
    :param cost: (int) what is a prize for cell

    :return:  void -&gt; only change objects
    &#34;&#34;&#34;
    if (card.coordinate in [5, 15, 25, 35] or not (card.number_of_houses or card.number_of_hotel))\
            and player.money &gt;= cost:
        self.make_trade(self, card, player, cost)</code></pre>
</details>
</dd>
<dt id="player.Player.stand_in_prison"><code class="name flex">
<span>def <span class="ident">stand_in_prison</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to count turn if player in prison
(if player in prison he lose 2 turn)</p>
<p>:return: void -&gt; (only change objects)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stand_in_prison(self):
    &#34;&#34;&#34;
        This function is used to count turn if player in prison  (if player in prison he lose 2 turn)

        :return: void -&gt; (only change objects)
    &#34;&#34;&#34;
    if self.prison_counter &gt; 0:
        self.prison_counter -= 1
    else:
        self.in_prison = 0</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="player.Player" href="#player.Player">Player</a></code></h4>
<ul class="">
<li><code><a title="player.Player.bank_account" href="#player.Player.bank_account">bank_account</a></code></li>
<li><code><a title="player.Player.buy_hotel" href="#player.Player.buy_hotel">buy_hotel</a></code></li>
<li><code><a title="player.Player.buy_house" href="#player.Player.buy_house">buy_house</a></code></li>
<li><code><a title="player.Player.card_out_of_prison" href="#player.Player.card_out_of_prison">card_out_of_prison</a></code></li>
<li><code><a title="player.Player.check_for_buying_hotel" href="#player.Player.check_for_buying_hotel">check_for_buying_hotel</a></code></li>
<li><code><a title="player.Player.check_for_buying_house" href="#player.Player.check_for_buying_house">check_for_buying_house</a></code></li>
<li><code><a title="player.Player.check_for_sell" href="#player.Player.check_for_sell">check_for_sell</a></code></li>
<li><code><a title="player.Player.go_bankrupt" href="#player.Player.go_bankrupt">go_bankrupt</a></code></li>
<li><code><a title="player.Player.make_trade" href="#player.Player.make_trade">make_trade</a></code></li>
<li><code><a title="player.Player.move" href="#player.Player.move">move</a></code></li>
<li><code><a title="player.Player.out_of_prison_by_card" href="#player.Player.out_of_prison_by_card">out_of_prison_by_card</a></code></li>
<li><code><a title="player.Player.out_of_prison_by_cash" href="#player.Player.out_of_prison_by_cash">out_of_prison_by_cash</a></code></li>
<li><code><a title="player.Player.paid_tax" href="#player.Player.paid_tax">paid_tax</a></code></li>
<li><code><a title="player.Player.sell_hotel" href="#player.Player.sell_hotel">sell_hotel</a></code></li>
<li><code><a title="player.Player.sell_house" href="#player.Player.sell_house">sell_house</a></code></li>
<li><code><a title="player.Player.sell_to_player" href="#player.Player.sell_to_player">sell_to_player</a></code></li>
<li><code><a title="player.Player.stand_in_prison" href="#player.Player.stand_in_prison">stand_in_prison</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>